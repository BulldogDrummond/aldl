Hi Steve,

I would be very glad to help.

First of all, if you don't already know, the PCM communications are pretty much standard RS232 PC type, with the exceptions that it is NOT inverted like RS232 and doesn't have the higher split voltage power (typically +-12vdc) signal levels. It uses the PCM TTL levels of about 0-3vdc. And there is really no handshake happening. You can just read any RS232 spec/description and get all the comms information you need, just invert the data. The typical older PC with the RS232 port works just fine except for the voltage levels and the inversion. The 2-transistor or RS-232 chips take care of converting the signal back to the non-inverted TTL format the PCM needs. The newer PC's using just USB, can be set up to use the TTL level and proper polarity by buying a $3 "USB-to-Serial-TTL" type converter that simply omits the inverter and extra power supplies in the device. Most scan cables are made this way. Or you can get a $10 USB-to-RS232 type converter and use the 2-transistor inverter circuit with that one.

The actual comms are fairly simple. The scantool (typically at address "F0") sends a data request and the PCM (in this case at address "F4") responds in some way. Since the PCM is normally constantly outputting "idle traffic" to the bus (rpm, mph,...), we need to tell it to stop that in order to send our requests to it. Looking at the data definition files for the 94/95 we see that the request is "F4 56 08 AE" with the AE being the line checksum. This request is sometimes called a "shutup" or a "disable normal comms" command. The PCM responds with an identical echo of the request if it agrees to shutup for a while (about 3 seconds). Then, within that 3 seconds, the scantool sends a real data request according to the type desired (engine, transmission, DTC, vehicle info,...). Each year has it's own definition set of available data. For example, for 94/95 LT1 engine data, this would be a request "F4 57 01 00 B4". The B4 is the checksum. Then very shortly after the end of that (about 1-2 msecs) the PCM sends back a string of data "F4 92 01 ..... CS". That string of data has all the engine data, which can be interpreted using the data definition file. The "F4" is the pcm address, the 57 or 92 is the message length (not actual but calculated using a weird formula, not really too useful as long as you already know how long it is supposed to be), the "01" is the mode number and the "00" is the message number. All of this can be found in the definition file. To use the checksum, simply add up all the bytes including the checksum byte, and the lower two bytes of the total should be "00" if the data is not corrupted.
I recommend waiting about 5 msecs before transmitting a new request after receiving data from the PCM, to make sure the PCM is ready to receive it. As long as you keep sending requests within 3 seconds of the last reception, the PCM will stay in diagnostic mode and will not resume the idle traffic. If you do wait too long, you will have to send the shutup request again. It is best to time the shutup request to not crash atop the PCM idle traffic, but most PC's cannot reliably time that accurately, so you can just send several timed requests assuming that at least one is "in the clear". I found that 3 subsequent shutup requests spaced 75 msecs apart works every time.

If you don't already have one, you can download some definition set files at my Scan9495 download site.
http://www.mediafire.com/download/bk.../ALDLstuff.zip
The one you need for an LT1 F-car would be A274 for A/T or A273 for M/T (almost identical for the engine specs). Use the Index.doc file to see a list of them all.

The tricky part of all this is using something that can work at the oddball baud rate of 8192 bit/second. Most modern PC's have hardware that can do this, but Windows has no ability to directly set that rate, so the app must perform it. That is why something like Hi-term doesn't work. Some USB adapters have that baud rate available and others do have it. Chips made by Prolific do not, while FTDI chips do.

Feel free to ask any questions anytime. I also work part time developing hardware interfaces using microcontrollers, so may be able to help in that area.

In return, perhaps you could share your experiences using my app in some detail, and feel free to critique it. I get really sparse feedback considering there have been well over 100 downloads. I especially would like to hear from any Windows-8 users. Some say it works for them and others say not. There must be some "fix" for that.

Look for a new release in the next few weeks that adds data recording and playback like Datamaster. Right now it works, but I am having fits with the enhanced graphing I plan to use.

Gary
