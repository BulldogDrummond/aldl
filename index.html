<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Aldl-io by resfilter</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Aldl-io</h1>
        <p>Make use of ALDL datastreams in gnu/linux</p>

        <p class="view"><a href="https://github.com/resfilter/aldl">View the Project on GitHub <small>resfilter/aldl</small></a></p>


        <ul>
          <li><a href="https://github.com/resfilter/aldl/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/resfilter/aldl/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/resfilter/aldl">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h2>
<a name="overview" class="anchor" href="#overview"><span class="octicon octicon-link"></span></a>overview</h2>

<p>this is a program designed to manage aldl datastreams from the 8192 baud series
of OBD-I GM ECMs under gnu/linux based operating systems, but best tested with
EE mask LT1 ecms.</p>

<h2>
<a name="goals" class="anchor" href="#goals"><span class="octicon octicon-link"></span></a>goals</h2>

<ul>
<li>adaptable to any ecm that adheres to the standard 8192 baud aldl protocol</li>
<li>low cpu use for low power devices such as raspberry pi and netbooks</li>
<li>easy configuration that's easily adapted from other formats</li>
<li>portable to at least ARM and x86</li>
<li>highest throughput possible but with adjustable throttling</li>
<li>highest connection stability and reconnect rate possible</li>
<li>transparent and stupid simple api</li>
<li>very easy to make plugins thread-safe</li>
<li>fast and easy automatic datalogging to csv format</li>
<li>simple ncurses interface for raspberry pi based dashboard</li>
</ul><h2>
<a name="instructions" class="anchor" href="#instructions"><span class="octicon octicon-link"></span></a>instructions</h2>

<p>to build and run it, you'll need to:</p>

<ul>
<li>install libftdi and libncurses.</li>
</ul><p>if you run debian/ubuntu/whatever, then: apt-get install ncurses-dev libftdi-dev</p>

<ul>
<li>'rmmod ftdi_sio'  or blacklist it.</li>
</ul><p>this removes the the in-kernel ftdi driver.  this program uses libftdi for raw
access to the usb-serial adaptor, and will not work while ftdi_sio is loaded.</p>

<ul>
<li><p>make sure your user has permissions to read/write usb devices.</p></li>
<li><p>configuration.  see below.</p></li>
<li><p>run it! './aldl-ftdi'</p></li>
</ul><p>by default, it only uses the ncurses display interface. the default modules
that run are also specified in aldl.conf.</p>

<p>if you want the datalogger and the display interface: ./aldl-ftdi datalogger</p>

<h2>
<a name="configuration" class="anchor" href="#configuration"><span class="octicon octicon-link"></span></a>configuration</h2>

<p>!! the config files are in examples/ !! </p>

<p>it's built to use this directory by default for testing.  you can change the
default 'root' config file (aldl.conf) in config.h, then edit aldl.conf's paths
if you want to store them somewhere else.</p>

<ul>
<li>aldl.conf: the root config file, specifies locations of the other config
files, as well as configures the serial driver, and a few timing options.</li>
<li>lt1.conf: this is a sample definition file for an LT1 F-body or B-Body.</li>
<li>datalogger.conf: configures the datalogger, including location and naming or
the logs themselves</li>
</ul><p>the only thing you should have to change to get this program up and running on
an LT1 is identifying your ftdi device somehow in aldl.conf.</p>

<p>there are instructions at the bottom of this file on various ways to do that.
but briefly, if you run lsusb, and you find your device, it'll be like:</p>

<p>Bus 001 Device 003: ID 0424:ec00 Some FTDI Device</p>

<p>there is also a command, ./aldl-ftdi devices which may give you more detailed
information about the ftdi devices on your system, or may not.  poorly tested.</p>

<p>then look in examples/aldl.conf. there's a PORT="d:bus/device" line. for this
example, PORT="D:001/003" would work</p>

<p>check out config.h if you're interested in 'tweaking' anything.</p>

<h2>
<a name="contents" class="anchor" href="#contents"><span class="octicon octicon-link"></span></a>contents</h2>

<p>main.c: sets up initial structures and spawns some threads, to get things going
        facilitates loading of modules and main config data, etc.</p>

<p>acquire.c: an object that runs an event loop full of functions from aldl-io,
           maintaining connection state and constructing a linked list buffer
           of parsed and verified aldl data.</p>

<p>error.c: a global error handling object.</p>

<p>aldl-io.h: all public functions are exported here.  this also explicitly
           includes aldl-types.h.</p>

<p>aldl-types.h: defines all public data structures used in this library.</p>

<p>aldldata.c: provides functions for data management, including construction of
            the linked list of records, parsing and conversion of raw data, and
            thread-safe read/write of critical data.</p>

<p>aldlcomm.c: provides communication protocols for dealing with the ECM, including
            sending and generating requests, retrieving raw packets of data,
            and verifying them.</p>

<p>useful.c: generic useful functions that are used by many different objects.</p>

<p>loadconfig.c: a stupid but useful configuration file routine that is bound to
              the equals sign.  includes routines for parsing the main config
              files directly, but has enough of an api to be used by modules.</p>

<p>serio-ftdi.c: an object that allows serial communications using the libftdi
              userland driver (via libusb).  this is the reccommended and only
              currently supported interface.</p>

<p>serio-dummy.c: a really stupid fake serial driver for debugging, that pretends
               to be an LT1 ecm.  seriously, it's really stupid, doesn't even
               check input, just spits out data in a serialized operation scope</p>

<p>modules/*: various output modules which can be executed by main.c to actually
           do stuff with the data, incl. display and logging.</p>

<h1>
<a name="notes" class="anchor" href="#notes"><span class="octicon octicon-link"></span></a>notes</h1>

<p>string to identify your ftdi interface (pick one):
   d:devicenode (usually at /proc/bus/usb)
   i:vendor:product
   i:vendor:product:index
   s:vendor:product:serial</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/resfilter">resfilter</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>